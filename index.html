<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Great Circle Distance on Map & 3D Globe</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; padding: 1em; }
    #controls { margin-bottom: 1em; }
    canvas { border: 1px solid #333; cursor: crosshair; }
    #container { display: flex; gap: 1em; align-items: flex-start; height: 50vh; }
    #mapCanvas { background: #000; height: 100% }
    #globeContainer { position: relative; aspect-ratio: 1/1; height: 100%; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Planet: 
      <select id="planetSelect">
        <option value="Flusion">Flusion</option>
        <option value="Xenon">Xenon</option>
        <option value="misc" selected>Custom (misc)</option>
      </select>
    </label>
    <label id="fileLabel">Map Image: <input type="file" id="mapInput" accept="image/*"></label>
    <label>Planet Radius: <input type="number" id="radiusInput" value="5100" style="width:6em;"></label>
    <span id="info">Click two points on the map.</span>
  </div>
  <div id="container">
    <canvas id="mapCanvas"></canvas>
    <div id="globeContainer"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let CROP_LEFT = 0;

    document.addEventListener('DOMContentLoaded', () => {
      select.dispatchEvent(new Event('change'));
    });

    const tag = '[GreatCircleMap]';
    const log = (...args) => console.log(tag, ...args);
    const err = (...args) => console.error(tag, ...args);

    // Presets: adjust image paths and radii as needed
    const presets = {
      Flusion: { radius: 5100, image: 'https://media.discordapp.net/attachments/1390244118516596816/1394724568345739475/image.png?ex=6877d9f9&is=68768879&hm=8d5b618f72661cc80ffe54dd15aa31c5e5363349589f7b19858c579669acf58d&=&format=webp&quality=lossless' },
      Xenon: { radius: 1544, image: 'https://media.discordapp.net/attachments/1356709323786420434/1394335830000275496/5_noomsterrainandmore_-_1_AGS.png?ex=6877c16f&is=68766fef&hm=b674d1cae68156ed5f8d60185f569ebd4c01f88290f9a6ee4c725516369fec52&=&format=webp&quality=lossless' }
    };

    const select = document.getElementById('planetSelect');
    const input = document.getElementById('mapInput');
    const radiusInput = document.getElementById('radiusInput');
    const info = document.getElementById('info');
    const fileLabel = document.getElementById('fileLabel');
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let img = new Image();

    select.addEventListener('change', () => {
      const val = select.value;
      if (val === 'misc') {
        fileLabel.style.display = '';
        radiusInput.disabled = false;
        input.disabled = false;
        info.textContent = 'Click two points on the map.';
        CROP_LEFT = 0;
      } else {
        CROP_LEFT = 660;
        const { radius, image } = presets[val];
        radiusInput.value = radius;
        radiusInput.disabled = true;
        img.onload = () => {
          const w = img.width - CROP_LEFT;
          const h = img.height;
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img,
            CROP_LEFT, 0,   w, h,   // source rect
                 0, 0,   w, h    // dest rect
          );
          initGlobe(image);
          info.textContent = `Loaded ${val}: radius ${radius}`;
        };
        img.onerror = e => err('Preset load error', e);
        img.src = image;
        fileLabel.style.display = 'none';
        input.disabled = true;
      }
    });

    input.addEventListener('change', e => {
      const file = e.target.files[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        initGlobe(url);
        info.textContent = 'Custom map loaded.';
      };
      img.onerror = e => err('Map load error', e);
      img.src = url;
    });

    let clicks = [];
    canvas.addEventListener('click', e => {
      if (!img.src) return;
      const rect   = canvas.getBoundingClientRect();
      // how many drawing‐buffer pixels per CSS pixel?
      const scaleX = canvas.width  / rect.width;
      const scaleY = canvas.height / rect.height;

      // map CSS click → internal coordinates
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top ) * scaleY;      clicks.push({ x, y });
      drawPoint(x, y);
      if (clicks.length === 2) {
        const [p1, p2] = clicks;
        const c1 = pixelToLatLon(p1.x, p1.y);
        const c2 = pixelToLatLon(p2.x, p2.y);
        const R = parseFloat(radiusInput.value) || 1;
        const d = greatCircleDistance(c1, c2, R);
        drawGreatCircle(c1, c2);
        updateGlobeArc(c1, c2);
        info.textContent = `Distance: ${d.toFixed(2)} units`;
        clicks = [];
      }
    });

    function drawPoint(x, y) {
      ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fill();
    }

    function pixelToLatLon(x, y) {
      return { lon: ((x/canvas.width)*360 - 180 + 540)%360 - 180, lat: 90 - (y/canvas.height)*180 };
    }

    const toRad = d => d * Math.PI/180;
    const toDeg = r => r * 180/Math.PI;

    function greatCircleDistance(a, b, R) {
      const φ1 = toRad(a.lat), φ2 = toRad(b.lat);
      const Δφ = toRad(b.lat - a.lat);
      const Δλ = toRad(b.lon - a.lon);
      const h = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    }

    function latLonToCartesian(lat, lon) {
      const φ = toRad(lat), λ = toRad(-lon);
      return new THREE.Vector3(
        Math.cos(φ) * Math.cos(λ),
        Math.sin(φ),
        Math.cos(φ) * Math.sin(λ)
      );
    }

    function cartesianToLatLon(v) {
      return { lat: toDeg(Math.asin(v.y)), lon: -toDeg(Math.atan2(v.z, v.x)) };
    }

    function drawGreatCircle(a, b) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const w = img.width - CROP_LEFT;
      const h = img.height;

      ctx.drawImage(img,
        CROP_LEFT, 0,   w, h,   // source rect
             0, 0,   w, h    // dest rect
      );
      const A = latLonToCartesian(a.lat, a.lon);
      const B = latLonToCartesian(b.lat, b.lon);
      const θ = Math.acos(Math.max(-1, Math.min(1, A.dot(B))));
      ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2;
      ctx.beginPath();
      let lastPx = null;
      for (let i = 0; i <= 128; i++) {
        const t = i / 128;
        const fA = Math.sin((1 - t) * θ) / Math.sin(θ);
        const fB = Math.sin(t * θ) / Math.sin(θ);
        const P = A.clone().multiplyScalar(fA).add(B.clone().multiplyScalar(fB)).normalize();
        const { lat, lon } = cartesianToLatLon(P);
        const px = ((lon + 180) / 360) * canvas.width;
        const py = ((90 - lat) / 180) * canvas.height;
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          if (lastPx !== null && Math.abs(px - lastPx) > canvas.width / 2) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        lastPx = px;
      }
      ctx.stroke();
    }

    let scene, camera, renderer, globe, arcLine, controls;
    function initGlobe(imageURL) {
      const container = document.getElementById('globeContainer');
      container.innerHTML = '';
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 2);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.7; controls.zoomSpeed = 0.7; controls.panSpeed = 0.5;
      controls.minDistance = 1.2; controls.maxDistance = 10;
      const geom = new THREE.SphereGeometry(1, 64, 64);
      const mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
      globe = new THREE.Mesh(geom, mat); scene.add(globe);

      const loader = new THREE.TextureLoader();
      // loader.setCrossOrigin('');

      loader.load(
        imageURL,
        tex => {
          const W = tex.image.width;
          tex.wrapS = THREE.ClampToEdgeWrapping;
          tex.wrapT = THREE.ClampToEdgeWrapping;
          tex.offset.x =  CROP_LEFT / W;
          tex.repeat .x = (W - CROP_LEFT ) / W;
          log('Texture loaded');
          globe.material.map = tex;
          globe.material.needsUpdate = true;
        },
        undefined,
        e => err('Texture load error', e)
      );
      animate();
    }

    function updateGlobeArc(a, b) {
      if (arcLine) scene.remove(arcLine);
      const A = latLonToCartesian(a.lat, a.lon);
      const B = latLonToCartesian(b.lat, b.lon);
      const θ = Math.acos(Math.max(-1, Math.min(1, A.dot(B))));
      const pts = [];
      for (let i = 0; i <= 128; i++) {
        const t = i / 128;
        const fA = Math.sin((1 - t) * θ) / Math.sin(θ);
        const fB = Math.sin(t * θ) / Math.sin(θ);
        pts.push(A.clone().multiplyScalar(fA).add(B.clone().multiplyScalar(fB)).normalize());
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const matLine = new THREE.LineBasicMaterial({ color: 0x00ffff });
      arcLine = new THREE.Line(geom, matLine);
      scene.add(arcLine);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
