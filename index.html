<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Great Circle Distance on Map & 3D Globe</title>
  <style>
    body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; padding: 1em; }
    #controls { margin-bottom: 1em; }
    canvas { border: 1px solid #333; cursor: crosshair; }
    #container { display: flex; gap: 1em; align-items: flex-start; }
    #mapCanvas { background: #000; }
    #globeContainer { position: relative; }
  </style>
</head>
<body>
  <div id="controls">
    <label>Planet: 
      <select id="planetSelect">
        <option value="Flusion">Flusion</option>
        <option value="Xenon">Xenon</option>
        <option value="misc" selected>Custom (misc)</option>
      </select>
    </label>
    <label id="fileLabel">Map Image: <input type="file" id="mapInput" accept="image/*"></label>
    <label>Planet Radius: <input type="number" id="radiusInput" value="6371" style="width:6em;"></label>
    <span id="info">Click two points on the map.</span>
  </div>
  <div id="container">
    <canvas id="mapCanvas" width="800" height="400"></canvas>
    <div id="globeContainer"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const tag = '[GreatCircleMap]';
    const log = (...args) => console.log(tag, ...args);
    const err = (...args) => console.error(tag, ...args);

    // Presets: adjust image paths and radii as needed
    const presets = {
      Flusion: { radius: 5100, image: 'flusion.jpg' },
      Xenon: { radius: 5000, image: '-flusion.jpg' }
    };

    const select = document.getElementById('planetSelect');
    const input = document.getElementById('mapInput');
    const radiusInput = document.getElementById('radiusInput');
    const info = document.getElementById('info');
    const fileLabel = document.getElementById('fileLabel');
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let img = new Image();

    select.addEventListener('change', () => {
      const val = select.value;
      if (val === 'misc') {
        fileLabel.style.display = '';
        radiusInput.disabled = false;
        input.disabled = false;
        info.textContent = 'Click two points on the map.';
      } else {
        const { radius, image } = presets[val];
        radiusInput.value = radius;
        radiusInput.disabled = true;
        fetch(image)
          .then(res => {
            if (!res.ok) throw new Error('HTTP ${res.status}');
            return res.blob();
          })
          .then(blob => {
            const url = URL.createObjectURL(blob);
            img.onload = () => {
              canvas.width = img.width();
              canvas.height = img.height();
              ctx.drawImage(img, 0, 0);
              initGlobe(url);
              info.textContent = 'Preset map loaded.';
            }
          })
        img.onerror = e => err('Preset load error', e);
        img.src = image;
        fileLabel.style.display = 'none';
        input.disabled = true;
      }
    });

    input.addEventListener('change', e => {
      const file = e.target.files[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        initGlobe(url);
        console.log(url);
        info.textContent = 'Custom map loaded.';
      };
      img.onerror = e => err('Map load error', e);
      img.src = url;
    });

    let clicks = [];
    canvas.addEventListener('click', e => {
      if (!img.src) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      clicks.push({ x, y });
      drawPoint(x, y);
      if (clicks.length === 2) {
        const [p1, p2] = clicks;
        const c1 = pixelToLatLon(p1.x, p1.y);
        const c2 = pixelToLatLon(p2.x, p2.y);
        const R = parseFloat(radiusInput.value) || 1;
        const d = greatCircleDistance(c1, c2, R);
        drawGreatCircle(c1, c2);
        updateGlobeArc(c1, c2);
        info.textContent = `Distance: ${d.toFixed(2)} units`;
        clicks = [];
      }
    });

    function drawPoint(x, y) {
      ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fill();
    }

    function pixelToLatLon(x, y) {
      return { lon: ((x/canvas.width)*360 - 180 + 540)%360 - 180, lat: 90 - (y/canvas.height)*180 };
    }

    const toRad = d => d * Math.PI/180;
    const toDeg = r => r * 180/Math.PI;

    function greatCircleDistance(a, b, R) {
      const φ1 = toRad(a.lat), φ2 = toRad(b.lat);
      const Δφ = toRad(b.lat - a.lat);
      const Δλ = toRad(b.lon - a.lon);
      const h = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    }

    function latLonToCartesian(lat, lon) {
      const φ = toRad(lat), λ = toRad(-lon);
      return new THREE.Vector3(
        Math.cos(φ) * Math.cos(λ),
        Math.sin(φ),
        Math.cos(φ) * Math.sin(λ)
      );
    }

    function cartesianToLatLon(v) {
      return { lat: toDeg(Math.asin(v.y)), lon: -toDeg(Math.atan2(v.z, v.x)) };
    }

    function drawGreatCircle(a, b) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      const A = latLonToCartesian(a.lat, a.lon);
      const B = latLonToCartesian(b.lat, b.lon);
      const θ = Math.acos(Math.max(-1, Math.min(1, A.dot(B))));
      ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2;
      ctx.beginPath();
      let lastPx = null;
      for (let i = 0; i <= 128; i++) {
        const t = i / 128;
        const fA = Math.sin((1 - t) * θ) / Math.sin(θ);
        const fB = Math.sin(t * θ) / Math.sin(θ);
        const P = A.clone().multiplyScalar(fA).add(B.clone().multiplyScalar(fB)).normalize();
        const { lat, lon } = cartesianToLatLon(P);
        const px = ((lon + 180) / 360) * canvas.width;
        const py = ((90 - lat) / 180) * canvas.height;
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          if (lastPx !== null && Math.abs(px - lastPx) > canvas.width / 2) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        lastPx = px;
      }
      ctx.stroke();
    }

    let scene, camera, renderer, globe, arcLine, controls;
    function initGlobe(imageURL) {
      const container = document.getElementById('globeContainer');
      container.innerHTML = '';
      container.style.height = canvas.height + 'px';
      container.style.width = canvas.height + 'px';
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 2);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.7; controls.zoomSpeed = 0.7; controls.panSpeed = 0.5;
      controls.minDistance = 1.2; controls.maxDistance = 10;
      const geom = new THREE.SphereGeometry(1, 64, 64);
      const mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
      globe = new THREE.Mesh(geom, mat); scene.add(globe);
      new THREE.TextureLoader().load(
        imageURL,
        tex => { log('Texture loaded'); globe.material.map = tex; globe.material.needsUpdate = true; },
        undefined,
        e => err('Texture load error', e)
      );
      animate();
    }

    function updateGlobeArc(a, b) {
      if (arcLine) scene.remove(arcLine);
      const A = latLonToCartesian(a.lat, a.lon);
      const B = latLonToCartesian(b.lat, b.lon);
      const θ = Math.acos(Math.max(-1, Math.min(1, A.dot(B))));
      const pts = [];
      for (let i = 0; i <= 128; i++) {
        const t = i / 128;
        const fA = Math.sin((1 - t) * θ) / Math.sin(θ);
        const fB = Math.sin(t * θ) / Math.sin(θ);
        pts.push(A.clone().multiplyScalar(fA).add(B.clone().multiplyScalar(fB)).normalize());
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const matLine = new THREE.LineBasicMaterial({ color: 0x00ffff });
      arcLine = new THREE.Line(geom, matLine);
      scene.add(arcLine);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
